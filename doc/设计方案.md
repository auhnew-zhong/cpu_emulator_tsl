# TSL软核CPU模拟器设计文档

## 一、项目概述
TSL软核CPU模拟器是一个用纯C语言实现的处理器仿真器，旨在通过软件模拟TSL指令集架构，帮助理解计算机体系结构。项目最终目标是能在该模拟器上运行Linux系统。目前已实现TSL基础指令集，包括MOV、JMP、BIT_OP等核心指令，并具备基本的寄存器和内存管理功能📋 **[README.md](../README.md)**。

## 二、系统架构
### 2.1 整体结构
模拟器采用模块化设计，主要包含以下核心组件：
- **CPU模块**：负责指令取指、解码和执行，包含16个32位通用寄存器(R0-R15)和程序计数器(PC)
- **总线模块**：作为CPU与内存之间的通信桥梁
- **内存模块**：模拟32KB大小的DRAM，基地址为0x00000000
- **指令集**：实现TSL架构的基础指令，包括数据传输、逻辑运算、控制流等类型

### 2.2 数据通路
```
[CPU] <--> [BUS] <--> [DRAM]
```
CPU通过总线接口与内存进行数据交互，总线模块实现了数据的加载和存储功能📗 [bus.c](../src/bus.c)。

## 三、核心模块设计
### 3.1 CPU模块
CPU结构体定义如下：
```c
typedef struct CPU {
    uint32_t regs[16];          // 16个32位寄存器
    uint32_t pc;                // 程序计数器
    struct BUS bus;             // 连接到总线
} CPU;
```
主要功能函数包括：
- `cpu_init()`: 初始化CPU状态，设置初始PC值和寄存器状态
- `cpu_fetch()`: 从内存获取指令
- `cpu_execute()`: 解码并执行指令
- `dump_registers()`: 打印寄存器状态用于调试📘 [cpu.h](../includes/cpu.h)。

### 3.2 内存模块
DRAM设计参数：
- 大小：32KB (1024*32字节)
- 基地址：0x00000000
- 支持8/16/32/64位数据加载和存储

关键实现：
```c
uint64_t dram_load(DRAM* dram, uint64_t addr, uint64_t size) {
    switch (size) {
        case 8:  return dram_load_8(dram, addr);  break;
        case 16: return dram_load_16(dram, addr); break;
        case 32: return dram_load_32(dram, addr); break;
        case 64: return dram_load_64(dram, addr); break;
        // ...错误处理...
    }
}
```
[DRAM设计参数](../src/dram.c)。

### 3.3 指令集实现
目前支持的主要指令类型：
1. **数据传输指令**：如MOV(8字节指令)
2. **逻辑运算指令**：如BIT_OP(与/或/异或操作)
3. **控制流指令**：如JMPC(条件跳转)、JMP(无条件跳转)、BL(分支链接)
4. **特殊指令**：如TRIGGER(触发信号采样)、RET(返回)、NOP(空操作)

指令解码流程：根据指令长度(1/2/4/8字节)和操作码分发到相应执行函数📗 [cpu.c](../src/cpu.c)。

## 四、编译与运行
### 4.1 编译流程
项目使用Makefile进行构建，主要编译步骤：
```bash
make               # 编译生成模拟器可执行文件
./tsl_cpu_emulator <binary.bin>  # 运行模拟器，加载二进制文件
```
Makefile定义了编译器选项、源文件列表和链接规则📋 **[Makefile](../Makefile)**。

### 4.2 测试程序
测试程序位于tests目录，可通过汇编编写测试用例，编译生成二进制文件后由模拟器加载执行。主程序通过`read_file()`函数将二进制文件加载到DRAM中📗 [tsl_cpu_main.c](../tsl_cpu_main.c)。

## 五、调试与优化
### 5.1 调试功能
目前实现的调试功能：
- 寄存器状态打印(dump_registers)
- 指令执行跟踪
- 错误信息输出

建议扩展方向：
- 集成JTAG调试接口，支持硬件级调试
- 添加断点和单步执行功能
- 实现内存和寄存器监视📋 **[JTAG调试分析.md](../doc/JTAG调试分析.md)**

### 5.2 设计优化
主要优化建议：
1. **模块化解耦**：将CPU与总线的紧耦合改为通过接口交互
2. **指令解码优化**：使用指令表和函数指针替代大量switch-case
3. **错误处理强化**：定义错误码，完善资源清理机制
4. **测试覆盖**：添加单元测试用例，实现自动化测试📋 **[设计优化方案](./设计优化.md)**

## 六、TSLCompiler需求分析

TSLCompiler编译在Trigger功能中处于中游。用户层在上游，逻辑层以及硬件层在下游。因此，梳理清上下游需求依赖关系至关重要。

### 5.3.1 逻辑需求分析

TSLCompiler作为连接用户层和逻辑层的关键组件，需要满足以下逻辑层需求：

#### 指令集兼容性需求
- **TSL指令集支持**：编译器必须能够生成完整的TSL指令集，包括：
  - 数据传输指令：MOV(0x7)加载立即数到寄存器
  - 逻辑运算指令：BIT_OP(0x1)支持位运算(&、|、^)和LOGIC_OP(0x2)逻辑运算
  - 控制流指令：JMPC(0x0)条件跳转、JMP(0x5)无条件跳转、BL(0x9)分支链接
  - 特殊指令：TRIGGER(0x3)触发信号采样、TRIGGER_POS(0x4)设定触发采样范围

#### 寄存器管理需求
- **寄存器分配**：编译器需要有效管理16个32位通用寄存器(R0-R15)
- **寄存器优化**：实现寄存器分配算法，减少内存访问，提高执行效率
- **程序计数器管理**：正确处理PC寄存器的跳转和分支逻辑

#### 内存布局需求
- **地址空间管理**：适配32KB DRAM(基地址0x00000000)的内存布局
- **数据对齐**：支持8/16/32/64位数据的正确对齐和访问
- **内存优化**：合理安排代码段、数据段和堆栈段的内存分配

#### Trigger功能集成需求
- **信号采样支持**：编译器需要理解和正确生成TRIGGER相关指令
- **时序控制**：支持TRIGGER_POS指令设定的触发采样范围逻辑
- **仿真控制**：与模拟器的暂停/恢复机制协调工作

### 5.3.2 Humc需求分析

Humc作为TSLCompiler的上游组件，代表用户层的高级抽象需求：

#### 高级语言抽象需求
- **语法解析**：Humc需要提供清晰的语法结构，便于TSLCompiler进行词法和语法分析
- **语义表达**：支持复杂的控制结构(循环、条件、函数调用)到TSL指令的映射
- **类型系统**：提供强类型检查，确保生成的TSL代码类型安全

#### 编译接口需求
- **中间表示(IR)**：Humc需要生成标准化的中间表示，便于TSLCompiler优化和代码生成
- **符号表管理**：提供完整的符号信息(变量、函数、标签)供TSLCompiler使用
- **错误处理**：建立统一的错误报告机制，便于调试和错误定位

#### 特殊功能支持需求
- **Trigger语义**：Humc需要提供高级的触发和采样语义抽象
- **硬件抽象**：隐藏底层硬件细节，提供用户友好的编程接口
- **调试信息**：生成调试符号和行号信息，支持源码级调试

#### 性能优化需求
- **编译速度**：Humc到TSL的编译过程需要高效，支持增量编译
- **代码质量**：生成的中间表示应便于TSLCompiler进行优化
- **资源管理**：合理管理编译过程中的内存和计算资源

#### 兼容性需求
- **标准兼容**：与现有的编译工具链保持兼容
- **平台适配**：支持不同开发环境和操作系统
- **版本管理**：提供清晰的版本控制和向后兼容策略

通过以上需求分析，TSLCompiler需要在Humc的高级抽象和TSL软核CPU的底层实现之间建立有效的桥梁，确保整个编译工具链的高效运行和最终在模拟器上运行Linux系统的目标实现。

## 七、未来工作
1. 完成TSL指令集的完整实现
2. 优化模拟器性能，提升指令执行速度
3. 完善调试工具链，支持高级调试功能
        