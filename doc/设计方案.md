# TSL软核CPU模拟器设计文档

## 一、项目概述
TSL软核CPU模拟器以纯C实现，面向TSL指令集的取指/解码/执行流程仿真，支持多字节变长指令、颜色化执行日志、信息表驱动的显示/执行/域与定时器配置。当前已实现核心指令子集与基本调试能力，示例程序可在仿真器中运行并打印状态📋 `README.md`。

## 二、系统架构
### 2.1 整体结构
- `CPU`：执行引擎与状态机，包含通用寄存器、程序计数器、域/计数器/定时器状态以及上一周期寄存器快照
- `BUS`：统一的内存访问接口，提供按位宽的装载/存储
- `DRAM`：32KB 仿真内存，基地址 `0x00000000`
- `InfoDB`：显示/执行/域/定时器信息表，支持按ID查询文案与策略
- `Scripts`：二进制反汇编与内存转换脚本（`BinToAsm.py`、`BinToMem.py`）

### 2.2 数据通路
```
[CPU] <--> [BUS] <--> [DRAM]
```
CPU 通过总线访问 DRAM；BUS 统一处理 `8/16/32/64` 位宽的读写📗 `src/bus.c`。

## 三、核心模块设计
### 3.1 CPU模块
结构体：📗 `include/cpu.h`
```
typedef struct CPU {
    uint32_t regs[17];          // R0-R15 + LR(R16)
    uint32_t pc;                // 程序计数器
    struct BUS bus;             // 总线
    uint32_t prev_regs[16];     // 上一周期快照（R0-R15）
    uint8_t  domain;            // 当前域
    uint32_t counters[2];       // 计数器
    uint32_t timer[2];          // 定时器值
    uint8_t  timer_enabled[2];  // 定时器使能
    uint32_t timer_threshold[2];// 定时器阈值
    uint32_t timer_target_pc[2];// 定时器触发跳转目标PC
} CPU;
```
关键函数：📗 `src/cpu.c`
- `cpu_init()`: 初始化CPU状态，设置初始PC值和寄存器状态
- `cpu_fetch`：按当前 `pc` 与长度判定取指，调用 `bus_load` 返回指令（`src/cpu.c:105-121`）
- `cpu_execute`：保存快照、`pc+=inst_length`、分发到 `decode_*_byte_inst`，末尾调用 `timer_tick_and_jump`（`src/cpu.c:775-801`）
- `dump_registers`：打印 R0-R15、计数器/定时器/PC（`src/cpu.c:738-761`）

### 3.2 内存模块
参数与接口：📗 `include/dram.h`
- `DRAM_SIZE=32KB`，`DRAM_BASE=0x00000000`
- 提供 `dram_load_{8,16,32,64}` 与 `dram_store_{8,16,32,64}`（实现见 `src/dram.c`）

### 3.3 指令与解码
统一格式参考📗 `doc/inst_format.md`：
- 1字节：`trigger(0x3)`、`ret(0x8)`、`timer_set(0xF)`
- 2字节：`trigger_pos(0x4)`、`jmp(0x5)`、`bl(0x9)`、`display(0xB)`、`exec(0xC)`、`edge_detect(0xE)`、`domain_set(0xA)`、`mov(0x7, func=1)`
- 4字节：`jmpc(0x0)`、`arith_op(0x1)`、`bit_slice(0x6)`、`load(0xD)`
- 8字节：`movi(0x7, func=0)`

端序策略：多字节指令按大端拼接与解码（`scripts/BinToAsm.py:121-123, 185-187`）。

PC更新与偏移：
- 取指后 `pc += inst_length`，执行阶段再按指令行为调整
- 有符号偏移：`jmpc` 以 `int8_t` 处理（`src/cpu.c:213-268`），`jmp` 8位符号扩展（`src/cpu.c:451-459`），`bl` 10位符号扩展（`src/cpu.c:487-496`）

### 3.4 特性与语义
- `edge_detect`：支持 `P/N/T/L/H/S/X` 映射（`src/cpu.c:565-598`）
  - `P` 上升沿，`N` 下降沿，`T` 跳变，`L` 稳定低，`H` 稳定高，`S` 稳定态，`X` 不关心
- `timer_set`：`[id(1bit), func(2bit)]` → `reset/disable/enable`（`src/cpu.c:679-697`）
- `domain_set`：更新当前域并打印域信息（`src/cpu.c:505-516`）
- `display/exec`：按ID查询信息表并输出/执行（`src/cpu.c:525-556`）
- `dump_registers`：额外打印计数器/定时器/PC，便于时序与控制流调试（`src/cpu.c:755-761`）

### 3.5 信息表与定时器
信息表接口：📗 `include/info_db.h`
- `get_complete_display_string`、`get_exec_info`、`get_domain_info`、`get_timer_info`
- `timer_parse_info`、`timer_tick_and_jump`（驱动阈值与跳转目标，`src/info_db.c`）

## 四、编译与运行
### 4.1 构建
```bash
make
./emulator examples/test_second_version/test_second_version.bin
```
Makefile 自动收集 `src/*.c` 并生成可执行文件📗 `Makefile`。

### 4.2 示例程序
- 计时器示例：`examples/test_timer/test_timer.s` 与生成的 `*.bin`
- 第二版综合示例：`examples/test_second_version/test_second_version.*`，覆盖 `bit_slice/arith_op/jmpc/edge_detect` 等

## 五、调试与输出
- 颜色化日志：使用 ANSI 前景与粗体输出（`include/color.h`）
- 指令地址与执行轨迹：在 `cpu_execute` 开始打印 `pc` 与反汇编语义
- 显示/执行/域/定时器内容：依赖信息表，未命中时输出错误

## 六、设计要点与优化
- 指令长度判定：`cpu_fetch` 调用 `getInstLength`，并校验内存边界（`src/cpu.c:105-121`）
- 快照机制：在每条指令执行前保存 `prev_regs` 以支持边沿检测与显示对比（`src/cpu.c:781-782`）
- 一致的端序与解码：脚本与仿真器保持大端一致性，便于交叉验证
- 建议优化：以表驱动替换部分 `switch`，增强错误码与异常路径，扩充单元测试覆盖

## 七、未来工作
- 完成指令子集的扩展与一致性测试
- 引入断点/单步与观测点，完善调试器能力
- 统一脚本/仿真端的消息格式，提升可观测性

## 附：关键代码参考
- `exec_JMPC`：`src/cpu.c:213-268`
- `exec_JMP/exec_BL`：`src/cpu.c:451-459, 487-496`
- `exec_EDGE_DETECT`：`src/cpu.c:565-598`
- `exec_TIMER_SET`：`src/cpu.c:679-697`
- `decode_two_byte_inst`：`src/cpu.c:607-639`
- `dump_registers`：`src/cpu.c:738-761`
